[{"name": "app.py", "content": "from shiny import App, render, ui, reactive\nfrom io import StringIO\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom shiny_download import get_url\nplt.style.use('ggplot')\n\nurl = r'https://raw.githubusercontent.com/CptQuak/lol_stats/shiny-app/shinydata/lol.csv'\nrelevant_columns = ['playername', 'league', 'position', 'teamname', 'kills', 'deaths', 'assists', 'dpm', 'total cs']\n\n\n##########################################################\napp_ui = ui.page_fluid(    \n    ui.panel_title('League of legends 2023 season players stats'),\n    ui.navset_tab_card(\n        # elements ----\n        ui.nav(\"a\", \"tab a content\"),\n        ui.nav(\"b\", \"tab b content\"),\n    ),\n    ui.markdown('''\n        App showing statistics describing performance of professional League of Legends players\n    '''),\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_numeric('num_players', 'Number of players', value=10),\n            ui.input_selectize(\"position\", \"Select position\", \n                dict(all='All positions', top=\"Toplane\", jng='Jungle' ,mid=\"Midlane\", bot='Ad carry', sup='Support'),\n                selected='all',\n            ),\n            ui.input_selectize(\"var\", \"Select variable\",\n                dict(average_kills=\"average_kills\", average_deaths=\"average_deaths\", \n                     average_assists='average_assists', average_dpm='average_dpm', average_cs='average_cs'),\n                selected='average_kills',\n            ),\n            ui.input_checkbox_group(\"tournaments\", \"Select torunaments (multiple)\", \n                           dict(MSI='MSI', LCK='LCK', LPL='LPL', LEC='LEC'), \n                           selected='MSI'\n            ),\n            ui.input_selectize(\"tab_sorting\", \"Sort table by\", \n                {x: x for x in ['total_kills', 'total_deaths', 'total_assists', 'highest_dpm', 'highest_cs']},\n                selected='top',\n            ),\n        ), \n        ui.panel_main(\n            ui.output_plot(\"plot\"),\n            ui.output_table('topstats')\n        )\n    )\n)\n\n\ndef server(input, output, session):\n    reactive_df = reactive.Value(pd.DataFrame())\n    \n    @reactive.Calc\n    async def get_data():\n        response = await get_url(url, 'string')\n        data = StringIO(response.data)\n        return data\n    \n    @reactive.Effect\n    async def _():\n        data = await get_data()\n        reactive_df.set(pd.read_csv(data, header=0))\n        print(reactive_df().head())\n\n    @output\n    @render.plot\n    def plot():\n        query_position = [input.position()] if input.position() != 'all' else ['top', 'jgl', 'mid', 'bot', 'sup']\n        df = reactive_df()\n        data = (\n            df\n            [(df['league'].isin(input.tournaments())) & (df['position'].isin(query_position))]\n            .groupby(['playername'])\n            .agg(\n                average_kills = pd.NamedAgg('kills', 'mean'),\n                average_deaths = pd.NamedAgg('deaths', 'mean'),\n                average_assists = pd.NamedAgg('assists', 'mean'),\n                average_dpm = pd.NamedAgg('dpm', 'mean'),\n                average_cs = pd.NamedAgg('total cs', 'mean'),\n            )\n            .reset_index()\n            .sort_values(input.var(), ascending=False)\n            .head(input.num_players())\n        )\n\n        fig, ax = plt.subplots(1, 1, figsize=(8, 4))\n        # im = ax.imshow(data2d, cmap=input.cmap(), vmin=input.range()[0], vmax=input.range()[1])\n        sns.barplot(data, x=input.var(), y='playername', color='#12b6f8', ax=ax)\n        return fig\n\n    @output\n    @render.table\n    def topstats():\n        query_position = [input.position()] if input.position() != 'all' else ['top', 'jgl', 'mid', 'bot', 'sup']\n        df = reactive_df()\n        data = (\n            df\n            [(df['league'].isin(input.tournaments())) & (df['position'].isin(query_position))]\n            .groupby(['playername'])\n            .agg(\n                total_kills = pd.NamedAgg('kills', 'sum'),\n                total_deaths = pd.NamedAgg('deaths', 'sum'),\n                total_assists = pd.NamedAgg('assists', 'sum'),\n                highest_dpm = pd.NamedAgg('dpm', 'max'),\n                highest_cs = pd.NamedAgg('total cs', 'max'),\n            )\n            .reset_index()\n            .sort_values(input.tab_sorting(), ascending=False)\n            .head(input.num_players())\n        )\n        return data\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "shiny_download.py", "content": "import json\nfrom typing import Any, Literal\n\n\nclass HttpResponse:\n    def __init__(self, status: int, data: Any):\n        self.status = status\n        self.data = data\n\n\nasync def get_url(\n    url: str, type: Literal[\"string\", \"bytes\", \"json\"] = \"string\"\n) -> HttpResponse:\n    \"\"\"\n    An async wrapper function for http requests that works in both regular Python and\n    Pyodide.\n\n    In Pyodide, it uses the pyodide.http.pyfetch() function, which is a wrapper for the\n    JavaScript fetch() function. pyfetch() is asynchronous, so this whole function must\n    also be async.\n\n    In regular Python, it uses the urllib.request.urlopen() function.\n\n    Args:\n        url: The URL to download.\n\n        type: How to parse the content. If \"string\", it returns the response as a\n        string. If \"bytes\", it returns the response as a bytes object. If \"json\", it\n        parses the reponse as JSON, then converts it to a Python object, usually a\n        dictionary or list.\n\n    Returns:\n        A HttpResponse object\n    \"\"\"\n    import sys\n\n    if \"pyodide\" in sys.modules:\n        import pyodide.http\n\n        response = await pyodide.http.pyfetch(url)\n\n        if type == \"json\":\n            # .json() parses the response as JSON and converts to dictionary.\n            data = await response.json()\n        elif type == \"string\":\n            # .string() returns the response as a string.\n            data = await response.string()\n        elif type == \"bytes\":\n            # .bytes() returns the response as a byte object.\n            data = await response.bytes()\n\n        return HttpResponse(response.status, data)\n\n    else:\n        import urllib.request\n\n        response = urllib.request.urlopen(url)\n        if type == \"json\":\n            data = json.loads(response.read().decode(\"utf-8\"))\n        elif type == \"string\":\n            data = response.read().decode(\"utf-8\")\n        elif type == \"bytes\":\n            data = response.read()\n\n        return HttpResponse(response.status, data)\n", "type": "text"}]